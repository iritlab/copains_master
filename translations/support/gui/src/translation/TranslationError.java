package translation;

import java.util.ArrayList;
import java.util.Scanner;
import java.util.regex.MatchResult;
import java.util.regex.Pattern;


/**
 * This class holds one error that might be generated by the translator,
 * with the format (row,column,error_text)
 * @author maelv
 */
public class TranslationError {
	public enum Type { ERROR, WARNING };
	
	private int rowInCode;
	private int columnInCode;
	private boolean rowAndColumnKnown,posStartEndKnown;
	private int posStart,posEnd; // absolute positions in token flow
	private String errorMessage;
	private Type type;

	public TranslationError(int rowInCode, int columnInCode, 
			int posStart, int posEnd, Type type, String errorMessage) {
		this.rowInCode = rowInCode;
		this.columnInCode = columnInCode;
		this.errorMessage = errorMessage;
		this.posStart = posStart;
		this.posEnd = posEnd;
		rowAndColumnKnown = true;
		posStartEndKnown = true;
		this.type = type;
	}
	
	public TranslationError(int rowInCode, int columnInCode, Type type, String errorMessage) {
		this.rowInCode = rowInCode;
		this.columnInCode = columnInCode;
		this.errorMessage = errorMessage;
		rowAndColumnKnown = true;
		posStartEndKnown = false;
		this.type = type;
	}
	
	public TranslationError(String errorMessage) {
		this.errorMessage = errorMessage;
		rowAndColumnKnown = false;
		posStartEndKnown = false;
		this.type = Type.ERROR;
	}

	@Override
	public String toString() {
		return ((hasRowAndColumn()) ?
				"line "+rowInCode+", col "+columnInCode+": "+(type==Type.ERROR?"error":"warning")+": "
				:"")
			+ errorMessage;
	}

	public boolean hasRowAndColumn() {
		return rowAndColumnKnown;
	}
	
	/**
	 * posFromStart and posLineFromStart are known
	 */
	public boolean hasPosStartEnd() {
		return posStartEndKnown;
	}
	
	public int getRowInCode() {
		return rowInCode;
	}

	public boolean isPosFromStartKnown() {
		return posStartEndKnown;
	}

	public int getPosStart() {
		return posStart;
	}
	public int getPosEnd() {
		return posEnd;
	}

	public int getColumnInCode() {
		return columnInCode;
	}

	public String getErrorMessage() {
		return errorMessage;
	}
	
	public Type getType() {
		return type;
	}

	public String getTypeString() {
		switch (type) {
		case ERROR:   return "error";
		case WARNING: return "warning";
		}
		return "";
	}
	
	
	/**
	 * 
	 */
	private static boolean isBeginOfMessage(String oneline) {
		return Pattern.matches("^[0-9]+:[0-9]+:.*", oneline);
	}
	
	private static TranslationError parseNewError(String line) {
		TranslationError t = new TranslationError(line); // default case
		Pattern p1 = 
			Pattern.compile("^([0-9]+):([0-9]+):([0-9]+):([0-9]+): ([a-z]+): (.*)$");
		// group description:  line      col     start     end       type     msg
	    // group number:  i=     1        2        3        4          5       6
		Scanner scan = new Scanner(line);
		if(p1.matcher(line).find()) {
			scan.findInLine(p1);
			MatchResult r = scan.match();
			t = new TranslationError(
				Integer.parseInt(r.group(1)),
				Integer.parseInt(r.group(2)),
				Integer.parseInt(r.group(3)),
				Integer.parseInt(r.group(4)),
				r.group(5).equals("error") ? Type.ERROR : Type.WARNING,
				r.group(6));
		}
		Pattern p2 = 
			Pattern.compile("^([0-9]+):([0-9]+): ([a-z]+): (.*)$");
		// group description:  line      col      type     msg
	    // group number:  i=     1        2        3        4
		if(p2.matcher(line).find()) {
			scan.findInLine(p2);
			MatchResult r = scan.match();
			t = new TranslationError(
				Integer.parseInt(r.group(1)),
				Integer.parseInt(r.group(2)),
				r.group(3).equals("error") ? Type.ERROR : Type.WARNING,
				r.group(4));
		}
		scan.close();
		return t;
	}
	/**
	 * Takes what is outputed by touist and translates into error messages
	 * TODO: for now, only ONE error is parsed!
	 * @param error
	 * @return
	 */
	public static ArrayList<TranslationError> parse(String errorOutput) {
		ArrayList<TranslationError> errors = new ArrayList<TranslationError>();
		
		String[] lines = errorOutput.split("\\n");
		
		TranslationError errorBeingRead = null;
		for(String line : lines) {
			if(isBeginOfMessage(line)) {
				if(errorBeingRead==null) { // no previous messages
				} else { // previous message is finished, save it
					errors.add(errorBeingRead);
				}
				errorBeingRead = parseNewError(line);
			}
			else if(errorBeingRead != null) { // a message is being read
				errorBeingRead.errorMessage = errorBeingRead.errorMessage + "\n" + line;
			}
		}
		if(errorBeingRead != null) // we do not forget to save the last message
			errors.add(errorBeingRead);
		return errors;
	}
}